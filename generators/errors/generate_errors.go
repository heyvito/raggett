package main

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func main() {
	pwd, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	bytes, err := os.ReadFile(filepath.Join(pwd, "errors.go"))
	if err != nil {
		panic(err)
	}

	var result = []string{
		"// Code generated by generators/generate_errors.go. DO NOT EDIT.",
		"// This file was generated by a tool. Modifications will be overwritten.",
		"package raggett",
		"import (",
		`"fmt"`,
		`"reflect"`,
		")",
	}

	msgRegexp := regexp.MustCompile(`^//\s+msg:(.*)`)
	wantsMsg := false
	wantsComments := false
	var sig errorSignature
	var msgTemplate messageFormat
	for i, l := range strings.Split(string(bytes), "\n") {
		if !wantsMsg && !wantsComments {
			if strings.HasPrefix(l, "//+errGen:") {
				sig = parseErrorSignature(i, l)
				wantsMsg = true
			}
			continue
		}

		if wantsMsg {
			res := msgRegexp.FindStringSubmatch(l)
			if res == nil {
				panic(fmt.Sprintf("[line %d] Expected message template. Got `%s'", i+1, l))
			}
			msg := strings.TrimSpace(res[1])
			msgTemplate = parseMessageTemplate(i, msg)
			wantsMsg = false
			wantsComments = true
			continue
		}

		if wantsComments {
			if l != "" {
				sig.comments = append(sig.comments, l)
			} else {
				result = append(result, "")
				result = append(result, sig.comments...)
				result = append(result, fmt.Sprintf("type %s struct {", sig.name))
				for _, p := range sig.params {
					result = append(result, fmt.Sprintf("%s string", p.name))
				}
				result = append(result,
					"}",
					fmt.Sprintf("\nfunc (e %s) Error() string {", sig.name))
				msgStr := ""
				for i := 0; i < len(msgTemplate.parts); i++ {
					msgStr += msgTemplate.parts[i]
					if i < len(msgTemplate.parts)-1 {
						msgStr += "%s"
					}
				}

				if len(msgTemplate.parts) == len(msgTemplate.variables) {
					// Here we have a last variable that's not between two
					// blocks of text
					msgStr += "%s"
				}

				var accessors []string
				for _, p := range sig.params {
					accessors = append(accessors, "e."+p.name)
				}
				result = append(result, fmt.Sprintf("return fmt.Sprintf(\"%s\", %s)", msgStr, strings.Join(accessors, ",")))
				result = append(result, "}")

				lowerCasedName := string(strings.ToLower(sig.name)[0]) + sig.name[1:]
				var funcParams []string
				for _, p := range sig.params {
					funcParams = append(funcParams, fmt.Sprintf("%s %s", p.name, p.paramKind))
				}
				result = append(result,
					fmt.Sprintf("func %s(%s) error {", lowerCasedName, strings.Join(funcParams, ",")),
					fmt.Sprintf("return %s{", sig.name))
				for _, p := range sig.params {
					result = append(result, fmt.Sprintf("%s: %s.%s,", p.name, p.name, p.accessor))
				}
				result = append(result, "}", "}")
				wantsComments = false
			}
		}

		res := strings.Join(result, "\n")
		p, err := format.Source([]byte(res))
		if err != nil {
			fmt.Printf("Formatting source failed. Generated sources are: \n\n%s", res)
			panic(err)
		}

		err = os.WriteFile(filepath.Join(pwd, "errors_generated.go"), p, 0666)
		if err != nil {
			panic(err)
		}
	}
}

type param struct {
	name      string
	paramKind string
	accessor  string
}

type wants int

const (
	wantsSpace wants = iota
	wantsDash
	wantsAngledBracket
	wantsInvocationEnd
	wantsInvocationCommaOrEnd
	wantsOptionalSpace
	wantsEOL
)

type errorSignature struct {
	name     string
	params   []param
	comments []string
}

func parseErrorSignature(i int, l string) errorSignature {
	l = strings.TrimPrefix(l, "//+errGen:")
	errorName := ""
	foundParen := false
	cur := 0
	for i, v := range []rune(l) {
		if v == '(' {
			foundParen = true
			cur = i + 1
			break
		}
		errorName += string(v)
	}

	if !foundParen {
		panic(fmt.Sprintf("[line %d] Unexpected end of line, expected `(`", i+1))
	}
	var params []param
	want := wantsSpace
	p := param{}
	for cur < len(l)-1 {
		switch want {
		case wantsSpace:
			if l[cur] == ' ' {
				want = wantsDash
			} else {
				p.name += string(l[cur])
			}

		case wantsDash:
			if l[cur] == '-' {
				want = wantsAngledBracket
			} else {
				p.paramKind += string(l[cur])
			}

		case wantsAngledBracket:
			if l[cur] != '>' {
				panic(fmt.Sprintf("[line %d, column %d] Expected > found %c", i+1, cur+1, l[cur]))
			}
			want = wantsInvocationCommaOrEnd
		case wantsInvocationCommaOrEnd:
			if l[cur] == '(' {
				p.accessor += "("
				want = wantsInvocationEnd
			} else if l[cur] == ',' {
				want = wantsOptionalSpace
				params = append(params, p)
				p = param{}
			} else if l[cur] == ')' {
				want = wantsEOL
				params = append(params, p)
				p = param{}
			} else {
				p.accessor += string(l[cur])
			}
		case wantsOptionalSpace:
			want = wantsSpace
			if l[cur] != ' ' {
				continue
			}
		case wantsInvocationEnd:
			if l[cur] != ')' {
				panic(fmt.Sprintf("[line %d, column %d] Expected ), found %c", i+1, cur+1, l[cur]))
			}
			p.accessor += ")"
			want = wantsInvocationCommaOrEnd
		case wantsEOL:
			panic(fmt.Sprintf("[line %d, column %d] Expected EOL, found %c", i+1, cur+1, l[cur]))
		}
		cur++
	}

	if p.name != "" {
		params = append(params, p)
	}

	return errorSignature{
		name:   errorName,
		params: params,
	}
}

type messageFormat struct {
	parts, variables []string
}

const (
	msgSlash = iota
	msgOptionallyOpenParen
	msgCloseParen
)

func parseMessageTemplate(i int, l string) messageFormat {
	var parts, templates []string
	tmp := ""
	cur := 0
	want := msgSlash
	for cur < len(l) {
		switch want {
		case msgSlash:
			if l[cur] == '\\' {
				want = msgOptionallyOpenParen
			} else {
				tmp += string(l[cur])
			}
		case msgOptionallyOpenParen:
			if l[cur] == '(' {
				// We have a variable.
				parts = append(parts, tmp)
				tmp = ""
				want = msgCloseParen
			} else {
				tmp += "\\"
				tmp += string(l[cur])
				want = msgSlash
			}
		case msgCloseParen:
			if l[cur] == ')' {
				templates = append(templates, tmp)
				tmp = ""
				want = msgSlash
			} else {
				tmp += string(l[cur])
			}
		}
		cur++
	}

	if want != msgSlash {
		panic(fmt.Sprintf("[line %d] Unexpected EOL", i+1))
	}

	if tmp != "" {
		parts = append(parts, tmp)
	}

	return messageFormat{
		parts:     parts,
		variables: templates,
	}
}
