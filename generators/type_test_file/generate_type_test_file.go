package main

import (
	"fmt"
	"go/format"
	"math"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
)

type Builder struct {
	strings.Builder
}

func (b *Builder) WriteFormat(f string, a ...interface{}) {
	_, _ = b.WriteString(fmt.Sprintf(f, a...))
	b.Blank()
}

func (b *Builder) Write(s ...string) {
	for _, v := range s {
		_, _ = b.WriteString(v)
		b.Blank()
	}
}

func (b *Builder) Blank() {
	_, _ = b.WriteRune('\n')
}

func main() {
	types := map[string]string{
		"int":     "65540",
		"int8":    "127",
		"int16":   "32766",
		"int32":   "1073741823",
		"int64":   "4611686018427387903",
		"uint":    "15",
		"uint8":   "128",
		"uint16":  "65535",
		"uint32":  "4294967295",
		"uint64":  "9223372036854775808",
		"float32": strconv.FormatFloat(math.MaxFloat32, 'f', -1, 32),
		"float64": strconv.FormatFloat(math.MaxFloat64, 'f', -1, 64),
		"byte":    "255",
		"bool":    "true",
		"string":  "string",
	}
	patterns := map[string]string{
		"int":     `^\d+$`,
		"int8":    `^\d+$`,
		"int16":   `^\d+$`,
		"int32":   `^\d+$`,
		"int64":   `^\d+$`,
		"uint":    `^\d+$`,
		"uint8":   `^\d+$`,
		"uint16":  `^\d+$`,
		"uint32":  `^\d+$`,
		"uint64":  `^\d+$`,
		"float32": `^\d+$`,
		"float64": `^\d+$`,
		"byte":    `^[a-f-0-9]+$`,
		"bool":    "^(true|false)$",
		"string":  "^string$",
	}
	combinations := map[string]string{
		"Form":     "form",
		"URLParam": "url-param",
		"Query":    "query",
		"Header":   "header",
	}
	valueFormatter := map[string]func(s string) string{
		"string": func(s string) string {
			return `"` + s + `"`
		},
	}

	output := &Builder{}
	output.Write(
		"// Code generated by generators/generate_errors.go. DO NOT EDIT.",
		"// This file was generated by a tool. Modifications will be overwritten.",
		"",
		"package raggett",
		"",
		"import \"net/http/httptest\"",
		"import \"net/url\"",
		"import \"net/http\"",
		"import \"strings\"",
		"import \"fmt\"",
		"import \"testing\"",
		"import \"github.com/stretchr/testify/assert\"",
		"",
		"type GeneratedRequestType struct {",
		"*Request",
	)

	sortedTypes := sortedKeysOf(types)
	sortedCombinations := sortedKeysOf(combinations)

	for _, t := range sortedTypes {
		for _, name := range sortedCombinations {
			tag := combinations[name]
			baseName := strings.ToUpper(string(t[0])) + t[1:]
			output.WriteFormat("%s%s %s `%s:\"%s-%s\" blank:\"false\" required:\"true\" pattern:\"%s\"`", baseName, name, t, tag, t, tag, strings.ReplaceAll(patterns[t], "\\", "\\\\"))
		}
	}

	output.Blank()

	for _, t := range sortedTypes {
		for _, name := range sortedCombinations {
			tag := combinations[name]
			if tag == "url-param" {
				// No arrays in url-param...
				continue
			}

			baseName := strings.ToUpper(string(t[0])) + t[1:]
			output.WriteFormat("%s%sArr []%s `%s:\"%s-%s-arr\" blank:\"false\" pattern:\"%s\"`", baseName, name, t, tag, t, tag, strings.ReplaceAll(patterns[t], "\\", "\\\\"))
		}
	}

	output.Write(
		"}",
		"var integrationTestRequestFields = struct {",
		"form map[string][]string",
		"query map[string][]string",
		"header map[string][]string",
		"urlParam map[string][]string",
		"} {",
	)

	var (
		form     = map[string][]string{}
		query    = map[string][]string{}
		header   = map[string][]string{}
		urlParam = map[string][]string{}
	)

	for _, t := range sortedTypes {
		v := types[t]
		for _, n := range sortedCombinations {
			tag := combinations[n]
			name := fmt.Sprintf("%s-%s", t, tag)
			val := []string{v}
			arrVal := []string{v, v}
			var target map[string][]string
			switch tag {
			case "form":
				target = form
			case "query":
				target = query
			case "header":
				target = header
			case "url-param":
				target = urlParam
			}
			target[name] = val
			if tag != "url-param" {
				target[name+"-arr"] = arrVal
			}
		}
	}

	fields := []string{"form", "query", "header", "urlParam"}
	for i, m := range []map[string][]string{form, query, header, urlParam} {
		output.WriteFormat("%s: map[string][]string{", fields[i])
		sortedM := sortedKeysOf(m)
		for _, k := range sortedM {
			v := m[k]
			var values []string
			for _, val := range v {
				values = append(values, fmt.Sprintf(`"%s"`, val))
			}
			output.WriteFormat(`"%s": []string{%s},`, k, strings.Join(values, ","))
		}
		output.Write("},")
	}
	output.Write("}")

	// Create request...

	output.Write(
		"func generateIntegrationTestRequest() *http.Request {",
		"urlParams := []string{",
	)
	for _, k := range sortedKeysOf(urlParam) {
		output.Write(`"` + urlParam[k][0] + `",`)
	}
	output.Write("}") // urlParams
	output.Write(`u := url.URL{}`)
	output.Write(`u.Path = fmt.Sprintf("/test/%s", strings.Join(urlParams, "/"))`)
	output.Write(`query := url.Values{}`)

	for _, k := range sortedKeysOf(query) {
		for _, v := range query[k] {
			output.WriteFormat(`query.Add("%s", "%s")`, k, v)
		}
	}
	output.Write(`u.RawQuery = query.Encode()`)
	output.Write("form := &url.Values{}")
	for _, k := range sortedKeysOf(form) {
		for _, v := range form[k] {
			output.WriteFormat(`form.Add("%s", "%s")`, k, v)
		}
	}
	output.Write(`req := httptest.NewRequest("POST", u.String(), strings.NewReader(form.Encode()))`)
	output.Write(`req.Header.Add("content-type", "application/x-www-form-urlencoded")`)

	for _, k := range sortedKeysOf(header) {
		for _, v := range header[k] {
			output.WriteFormat(`req.Header.Add("%s", "%s")`, k, v)
		}
	}
	output.Write(`return req`)
	output.Write("}") // func generateIntegrationTestRequest

	output.Write(`func assertIntegrationRequestData(t *testing.T, r *GeneratedRequestType) {`)

	for _, t := range sortedTypes {
		for _, name := range sortedCombinations {
			tag := combinations[name]
			baseName := strings.ToUpper(string(t[0])) + t[1:]
			val := types[t]
			if fn, ok := valueFormatter[t]; ok {
				val = fn(val)
			}
			createAssessment(output, fmt.Sprintf("%s-%s", t, tag), baseName+name, t, []string{val})
			if tag != "url-param" {
				createAssessment(output, fmt.Sprintf("%s-%s-arr", t, tag), baseName+name+"Arr", t, []string{val, val})
			}
		}
	}

	output.Write("}") // func assertIntegrationRequestData
	output.Blank()

	var params []string
	for _, t := range sortedTypes {
		params = append(params, "{"+t+"-url-param}")
	}

	output.WriteFormat(`var integrationTestURLPattern = "/test/%s"`, strings.Join(params, "/"))

	// Write file
	src := []byte(output.Builder.String())
	p, err := format.Source(src)
	if err != nil {
		fmt.Println("Failed formatting source.")
		fmt.Println(err)
		p = src
	}
	if err = os.WriteFile("reflect_integration_generated_test.go", p, 0666); err != nil {
		panic(err)
	}
}

func createAssessment(o *Builder, requestParamName, structFieldName, typeName string, value []string) {
	o.WriteFormat("t.Run(`Received %s equals %s`, func(t *testing.T) {", requestParamName, value[0])
	if len(value) == 1 {
		o.WriteFormat(`assert.Equal(t, %s(%s), r.%s)`, typeName, value[0], structFieldName)
	} else {
		o.WriteFormat(`assert.Equal(t, []%s{%s}, r.%s)`, typeName, strings.Join(value, ", "), structFieldName)
	}
	o.Write("})")
}

func sortedKeysOf(rawMap interface{}) []string {
	mt := reflect.TypeOf(rawMap)
	mv := reflect.ValueOf(rawMap)
	if mt.Kind() != reflect.Map {
		panic("sortedKeysOf requires a map")
	}

	if mt.Key().Kind() != reflect.String {
		panic("sortedKeysOf requires the map key type to be string")
	}

	keys := mv.MapKeys()

	arr := make([]string, 0, len(keys))
	for _, k := range keys {
		arr = append(arr, k.String())
	}

	sort.Strings(arr)
	return arr
}
