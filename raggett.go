package raggett

import (
	"context"
	"fmt"
	"mime/multipart"
	"net/http"

	"github.com/go-chi/chi"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// FileHeader is a convenience type for multipart.FileHeader. When using
// Raggett, both types are interchangeable.
type FileHeader multipart.FileHeader

// CustomRequestParser implements a ParseRequest that will be invoked with a
// request before the handler is invoked. Returning an error from this function
// prevents the handler from being invoked.
type CustomRequestParser interface {
	ParseRequest(r *Request) error
}

type fieldKind int

const (
	fieldKindURLParam fieldKind = iota
	fieldKindQuery
	fieldKindForm
	fieldKindHeader
	fieldKindBody
)

func (f fieldKind) String() string {
	switch f {
	case fieldKindURLParam:
		return "URL Param"
	case fieldKindQuery:
		return "Query String"
	case fieldKindForm:
		return "Form Field"
	case fieldKindHeader:
		return "Header"
	case fieldKindBody:
		return "Body"
	default:
		return "Unknown"
	}
}

// ErrorHandlerFunc represents a function responsible for handling runtime
// errors. Any captured exceptions will be passed to this function.
// Although both http.ResponseWriter and *Request are provided, it is not
// guaranteed that http.ResponseWriter have not already flushed its headers.
// This function can be used for logging, and returning custom error messages
// to clients.
type ErrorHandlerFunc func(err error, w http.ResponseWriter, r *Request)

// ValidationErrorHandlerFunc represents a function responsible for handling
// validation errors before a handler is invoked. This function can bbe used
// to provide custom error messages to clients.
type ValidationErrorHandlerFunc func(err ValidationError, w http.ResponseWriter, r *Request)

// RequestIdentifierGenerator represents a function that returns a unique
// identifier for requests handled by the Mux.
type RequestIdentifierGenerator func() string

const (
	defaultMaxMemory = 32 << 20 // 32 MB
)

type routeHandler struct {
	pattern  string
	handlers map[string]*handlerMetadata
}

type Mux struct {
	internalMux             *chi.Mux
	errorHandler            ErrorHandlerFunc
	validationErrorHandler  ValidationErrorHandlerFunc
	notFoundHandler         http.HandlerFunc
	methodNotAllowedHandler http.HandlerFunc
	identifierGenerator     RequestIdentifierGenerator
	logger                  *zap.Logger
	handlers                map[string]*routeHandler

	// Development defines whether the application is running in a development
	// environment. When set to true, error responses generated by Raggett will
	// include extra information about the runtime in order to aid development.
	// It is recommended to set this option to false on production environments,
	// since it may expose sensitive information for third-party.
	Development bool

	// MaxMemory defines the max memory allowed to be consumed for files on
	// a per-request basis. Files greater than this value will automatically be
	// flushed to a temporary location. The default value for this parameter is
	// 32 MB.
	MaxMemory int64
}

func NewMux(logger *zap.Logger) *Mux {
	mx := &Mux{
		identifierGenerator: defaultRequestIDGenerator,
		logger:              logger,
		MaxMemory:           defaultMaxMemory,
		handlers:            map[string]*routeHandler{},
	}
	mx.internalMux = chi.NewMux()
	mx.errorHandler = mx.defaultRuntimeErrorHandler
	mx.validationErrorHandler = mx.defaultValidationErrorHandler
	mx.notFoundHandler = mx.defaultNotFoundHandler
	mx.methodNotAllowedHandler = mx.defaultMethodNotAllowedHandler

	mx.internalMux.Use(mx.muxContextInjector)
	mx.internalMux.NotFound(mx.internalNotFoundDispatch)
	mx.internalMux.MethodNotAllowed(mx.internalMethodNotAllowedDispatch)
	return mx
}

func (mx *Mux) muxContextInjector(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), requestMuxContextKey, mx)
		handler.ServeHTTP(w, r.WithContext(ctx))
	})
}

func (mx *Mux) copy() *Mux {
	return &Mux{
		internalMux:             mx.internalMux,
		errorHandler:            mx.errorHandler,
		validationErrorHandler:  mx.validationErrorHandler,
		notFoundHandler:         mx.notFoundHandler,
		methodNotAllowedHandler: mx.methodNotAllowedHandler,
		identifierGenerator:     mx.identifierGenerator,
		logger:                  mx.logger,
		Development:             mx.Development,
		MaxMemory:               mx.MaxMemory,
	}
}

func (mx *Mux) internalNotFoundDispatch(w http.ResponseWriter, r *http.Request) {
	mx.notFoundHandler(w, r)
}

func (mx *Mux) internalMethodNotAllowedDispatch(w http.ResponseWriter, r *http.Request) {
	mx.methodNotAllowedHandler(w, r)
}

// ServeHTTP is the single method of the http.Handler interface that makes
// Mux interoperable with the standard library. It simply delegates the request
// to the internal chi.Mux instance.
func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	mx.internalMux.ServeHTTP(w, r)
}

// LogWith updates Raggett's logger instance to add structured context to it.
// Fields added here will be present in all requests, and do not affect the
// parent logger.
func (mx *Mux) LogWith(opts ...zap.Field) {
	mx.logger = mx.logger.With(opts...)
}

// RequestIdentifierGenerator sets a function responsible for returning a unique
// identifier for each incoming request. This identifier will be shown in every
// log entry generated by the request, and also returned through a Request-ID
// header on responses.
// The default implementation simply generates a UUID.
func (mx *Mux) RequestIdentifierGenerator(fn RequestIdentifierGenerator) {
	mx.identifierGenerator = fn
}

// HandleError sets the error handler for errors returned from requests or
// errors that occurs during the request processing. Validation errors do not
// call this handler, instead, use HandleValidationError.
// The default implementation responds using an internal handler that attempts
// to return an appropriate format depending on the Accept header provided by
// the client. When Development is set, extra information will be included in
// the response. Otherwise, a simpler error message will be returned.
func (mx *Mux) HandleError(handlerFunc ErrorHandlerFunc) {
	if handlerFunc == nil {
		handlerFunc = mx.defaultRuntimeErrorHandler
	}
	mx.errorHandler = handlerFunc
}

// HandleValidationError sets the error handler for validation errors.
// Validation errors are caused by requests that does not satisfy the request
// handler conditions (by using validation tags).
// The default implementation responds using an internal handler that attempts
// to return an appropriate format depending on the Accept header provided by
// the client. When Development is set, extra information will be included in
// the response. Otherwise, a simpler error message will be returned.
func (mx *Mux) HandleValidationError(handlerFunc ValidationErrorHandlerFunc) {
	if handlerFunc == nil {
		handlerFunc = mx.defaultValidationErrorHandler
	}
	mx.validationErrorHandler = handlerFunc
}

// NotFound sets a custom http.HandlerFunc for routing paths that could
// not be found. The default 404 handler is `http.NotFound`.
func (mx *Mux) NotFound(handler http.HandlerFunc) {
	if handler == nil {
		handler = mx.defaultNotFoundHandler
	}
	mx.notFoundHandler = handler
}

// MethodNotAllowed sets a custom http.HandlerFunc for routing paths where the
// method is unresolved. The default handler returns a 405 with an empty body.
func (mx *Mux) MethodNotAllowed(handler http.HandlerFunc) {
	if handler == nil {
		handler = mx.internalMethodNotAllowedDispatch
	}
	mx.internalMux.MethodNotAllowed(handler)
}

// Use appends a middleware handler to the Mux middleware stack.
//
// The middleware stack for any Mux will execute before searching for a matching
// route to a specific handler, which provides opportunity to respond early,
// change the course of the request execution, or set request-scoped values for
// the next http.Handler.
func (mx *Mux) Use(middlewares ...func(http.Handler) http.Handler) {
	mx.internalMux.Use(middlewares...)
}

// With adds inline middlewares for an endpoint handler.
func (mx *Mux) With(middlewares ...func(http.Handler) http.Handler) *Mux {
	newMX := mx.copy()
	newMX.internalMux = newMX.internalMux.With(middlewares...).(*chi.Mux)
	return newMX
}

// Connect adds the route `pattern` that matches a CONNECT http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Connect(pattern string, handlerFn interface{}) {
	mx.internalMux.Connect(pattern, mx.makeResponder("CONNECT", pattern, handlerFn))
}

// Delete adds the route `pattern` that matches a DELETE http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Delete(pattern string, handlerFn interface{}) {
	mx.internalMux.Delete(pattern, mx.makeResponder("DELETE", pattern, handlerFn))
}

// Get adds the route `pattern` that matches a GET http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Get(pattern string, handlerFn interface{}) {
	mx.internalMux.Get(pattern, mx.makeResponder("GET", pattern, handlerFn))
}

// Head adds the route `pattern` that matches a HEAD http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Head(pattern string, handlerFn interface{}) {
	mx.internalMux.Head(pattern, mx.makeResponder("HEAD", pattern, handlerFn))
}

// Options adds the route `pattern` that matches a OPTIONS http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Options(pattern string, handlerFn interface{}) {
	mx.internalMux.Options(pattern, mx.makeResponder("OPTIONS", pattern, handlerFn))
}

// Patch adds the route `pattern` that matches a PATCH http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Patch(pattern string, handlerFn interface{}) {
	mx.internalMux.Patch(pattern, mx.makeResponder("PATCH", pattern, handlerFn))
}

// Post adds the route `pattern` that matches a POST http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Post(pattern string, handlerFn interface{}) {
	mx.internalMux.Post(pattern, mx.makeResponder("POST", pattern, handlerFn))
}

// Put adds the route `pattern` that matches a PUT http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Put(pattern string, handlerFn interface{}) {
	mx.internalMux.Put(pattern, mx.makeResponder("PUT", pattern, handlerFn))
}

// Trace adds the route `pattern` that matches a TRACE http method to
// execute the `handlerFn` function, which must simply take a Request-based
// struct and return an optional error.
func (mx *Mux) Trace(pattern string, handlerFn interface{}) {
	mx.internalMux.Trace(pattern, mx.makeResponder("TRACE", pattern, handlerFn))
}

func (mx *Mux) registerHandler(method, pattern string, t *handlerMetadata) {
	pat, ok := mx.handlers[pattern]
	if !ok {
		pat = &routeHandler{
			pattern:  pattern,
			handlers: map[string]*handlerMetadata{},
		}
		mx.handlers[pattern] = pat
	}
	pat.handlers[method] = t
}

func (mx *Mux) handlerMetaFor(method, pattern string) *handlerMetadata {
	v, ok := mx.handlers[pattern]
	if !ok {
		return nil
	}

	h := v.handlers[method]
	return h
}

func (mx *Mux) makeResponder(method, pattern string, handlerFn interface{}) func(w http.ResponseWriter, r *http.Request) {
	meta, err := determineFuncParams(handlerFn)
	if err != nil {
		panic(err)
	}

	mx.registerHandler(method, pattern, meta)
	return func(w http.ResponseWriter, r *http.Request) {
		req := newRequest(mx, w, r)
		runtimeErr := loadAndApplyMeta(meta, req)
		if runtimeErr != nil {
			if validationErr, ok := runtimeErr.(ValidationError); ok {
				mx.validationErrorHandler(validationErr, w, req)
			} else {
				mx.errorHandler(runtimeErr, w, req)
			}
			return
		}

		func(r *Request) {
			defer func() {
				if err := recover(); err != nil {
					if err == errAbortRequest {
						return
					} else if e, ok := err.(error); ok {
						r.Logger.Error("Error writing response", zap.Error(e))
					} else {
						r.Logger.Error("Error writing response. Recovered from non-error panic:", zap.String("error", fmt.Sprintf("%s", e)))
					}

					if !r.flushedHeaders {
						r.SetStatus(http.StatusInternalServerError)
						r.flushHeaders()
					}
				}
			}()
			r.doRespond()
		}(req)
	}
}

func defaultRequestIDGenerator() string {
	return uuid.NewString()
}

type muxContextKey struct {
	key string
}

var requestMuxContextKey = muxContextKey{key: "__raggett_request_mux"}

func muxForRequest(r *http.Request) *Mux {
	v := r.Context().Value(requestMuxContextKey)
	if m, ok := v.(*Mux); ok {
		return m
	}
	return nil
}
